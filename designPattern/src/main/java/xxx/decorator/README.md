#装饰者模式
装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。<br>
参考: 
设计模式之禅 <br>
https://blog.csdn.net/yunhua_lee/article/details/38865605

###【业务】
假设你进入了一个信息安全管理非常严格的公司，这家公司不允许员工自行打印文档，所有的文档打印都需要交给文档打印系统统一管理。
文档打印系统会记录每次打印的时间、内容、打印人员。。。等等，以便后续出现问题的时候进行追查。
由于公司有很多的部门，每个部门的安全要求并不完全一样，同时每个部门关于文档打印也有自己的一些规定。
我们的任务就是要开发一套能够支持整个公司文档打印需求的系统。

###【发现变化】
文档打印系统面对的变化主要体现在：文档打印要求是变化的，不同的部门有不同的要求，同一个部门也可能修改自己的打印需求。
例如：
A部门是一个战略规划的部门，里面的资料都非常重要，打印的时候需要在页眉位置打印“绝密”，在页脚的位置打印“密级申明”，同时要加上“绝密文档”的水印；
B部门是内部培训部门，打印培训材料的时候需要在页眉位置打印“内部公开”，但不需要密级申明，同时加上“培训资料”的水印
C部门是对外宣传部门，打印宣传材料的时候只需要加上“公司logo”的水印；

###【设计模式方法】
设计模式封装变化的方法就是Decorator模式。Decorator模式定义如下：
“动态的给一个对象添加一些额外的职责”
《设计模式》一书中关于Decorator模式的描述并不很直观，我理解Decorator模式为“通过聚合的方式将动态变化的职责组合起来”。

我们详细看看Decorator模式是如何封装变化的。
首先，将变化的职责封装为独立的类。传统方式实现中，不同的职责是对应不同的函数调用，而设计模式中，不同的职责是不同的类；
其次，通过聚合将变化的职责组合起来。传统方式中，不同职责的组合是通过在一个函数中写多行代码来体现的，而设计模式中，通过对象的聚合将不同职责组合起来。

###【Decorator模式结构】
Component：定义一个对象接口（对应结构图中的operation函数），可以给这些对象动态添加职责 <br>
ConcreteComponent：定义一个对象，这个对象是实际的Component，将被Decorator修饰 <br>
Decorator：定义修饰对象的接口，Decorator实现的关键在于聚合了一个Component对象 <br>
ConcreteDecorator：具体的修饰对象 <br>